{
  "master": {
    "tasks": [
      {
        "id": 52,
        "title": "Enhance SG Value Filter Implementation",
        "description": "Upgrade the basic SG Value filter with sophisticated algorithms that calculate performance percentiles, compare to betting odds, and factor in course fit.",
        "details": "1. Extend the existing SG Value filter class that implements FilterInterface\n2. Implement percentile calculation for SG performance vs field using statistical methods\n3. Integrate with betting odds data service to extract implied probabilities\n4. Create a time-weighted performance algorithm with configurable weights (e.g., 70% recent 10 rounds, 30% season average)\n5. Develop a course fit correlation factor using the existing course DNA system\n6. Implement the value score algorithm: `valueScore = (performancePercentile - impliedProbabilityPercentile) * courseFitFactor`\n7. Add configuration UI options for time periods (last 10/20/40 rounds) and weighting factors\n8. Optimize calculations with memoization for performance\n\nCode structure:\n```typescript\nexport class SGValueFilter implements FilterInterface {\n  private sgStatsService: SGStatsService;\n  private oddsService: OddsService;\n  private courseDNAService: CourseDNAService;\n  \n  constructor(services: FilterServices) {\n    this.sgStatsService = services.sgStatsService;\n    this.oddsService = services.oddsService;\n    this.courseDNAService = services.courseDNAService;\n  }\n  \n  public filter(players: Player[], config: SGValueFilterConfig): Player[] {\n    // Implementation of enhanced algorithm\n    return players.filter(player => this.calculateValueScore(player, config) > config.threshold);\n  }\n  \n  private calculateValueScore(player: Player, config: SGValueFilterConfig): number {\n    // Implement value score calculation\n  }\n}\n```",
        "testStrategy": "1. Unit test the value score calculation with mock data for different player profiles\n2. Test with various configuration settings to ensure proper weighting\n3. Verify integration with betting odds service using mock responses\n4. Benchmark performance with large player datasets (100+ players)\n5. Test edge cases: players with limited historical data, extreme odds values\n6. Integration test with the FilterPanel component\n7. Compare results against manual calculations for a sample set of players",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Performance Percentile Calculation",
            "description": "Extend the SGValueFilter class to calculate performance percentiles based on SG statistics compared to the field",
            "dependencies": [],
            "details": "Create a method to calculate player performance percentiles using the sgStatsService. Implement statistical methods to determine where a player's SG performance ranks within the field. Include options for different time periods (last 10/20/40 rounds) as specified in the requirements. Use memoization to optimize repeated calculations.\n<info added on 2025-07-01T00:12:57.078Z>\nImplemented comprehensive performance percentile calculation system in SG Value filter at /filters/implementations/sg-value.ts:173-196. Created calculatePerformancePercentiles() function that processes player SG data and calculateTimeWeightedSG() with support for 'recent', 'extended', and 'season' time periods. Added recency weighting algorithm that balances tournament vs season data. Implemented proper percentile ranking using statistical methods and comprehensive error handling for missing data. The implementation supports configurable time periods and weighting factors as specified in requirements.\n</info added on 2025-07-01T00:12:57.078Z>",
            "status": "done",
            "testStrategy": "Write unit tests comparing calculated percentiles against pre-computed values for a sample dataset of players. Test edge cases like players with limited historical data."
          },
          {
            "id": 2,
            "title": "Integrate Betting Odds Analysis",
            "description": "Implement functionality to extract and analyze implied probabilities from betting odds data",
            "dependencies": [],
            "details": "Use the oddsService to retrieve betting odds for players. Convert odds to implied probabilities using standard formulas. Calculate percentile rankings based on these implied probabilities. Create a method that compares a player's performance percentile against their implied probability percentile to identify value discrepancies.\n<info added on 2025-07-01T00:16:30.894Z>\nEnhanced betting odds analysis with comprehensive probability calculation system. Implemented multi-format odds support (American, Decimal, Fractional) with auto-detection. Added sophisticated vig removal functionality to eliminate bookmaker margin bias. Enhanced calculateOddsPercentiles() with configurable odds format and vig removal. Implemented groupPlayersByMatchup() for proper vig calculation by betting group. Added configuration options for oddsFormat and removeVig in SGValueOptions interface. Created robust implied probability conversion with proper percentile ranking. The system now provides accurate market probability analysis by removing bookmaker bias and supporting multiple odds formats.\n</info added on 2025-07-01T00:16:30.894Z>",
            "status": "done",
            "testStrategy": "Test with mock odds data to verify correct probability conversion and percentile calculation. Validate that higher value scores are assigned to players whose performance exceeds their implied probability."
          },
          {
            "id": 3,
            "title": "Develop Course Fit Correlation Factor",
            "description": "Create an algorithm that calculates a course fit factor using the existing course DNA system",
            "dependencies": [],
            "details": "Utilize the courseDNAService to analyze how well a player's strengths match the current course characteristics. Develop a correlation algorithm that produces a multiplier (courseFitFactor) based on the alignment between player skills and course demands. Scale the factor appropriately to ensure it provides meaningful adjustments to the value score.\n<info added on 2025-07-01T00:18:34.723Z>\nIntegrated Course DNA service for sophisticated course fit correlation factor. Created an async calculateCourseFitFactors() function that analyzes how player strengths align with course characteristics using real Course DNA analysis. Implemented an intelligent fit score to factor conversion that scales from 0-100 score to 0.5-1.5 multiplier range, where 0.5 represents a disadvantage and 1.5 indicates a strong advantage.\n\nEnhanced SGValueOptions to include eventName parameter for course analysis and updated the Filter interface to support asynchronous operations. Made applyFilter async to properly integrate with the course DNA service. Added comprehensive error handling with graceful fallbacks to neutral factors when course analysis fails.\n\nThe implementation successfully produces a meaningful courseFitFactor that adjusts value scores based on the alignment between player skills and course demands, with proper scaling to ensure significant but balanced adjustments.\n</info added on 2025-07-01T00:18:34.723Z>",
            "status": "done",
            "testStrategy": "Test with various player profiles against different course types to ensure the correlation factor correctly identifies players whose skills match course requirements."
          },
          {
            "id": 4,
            "title": "Implement Time-Weighted Performance Algorithm",
            "description": "Create a configurable time-weighted performance calculation system",
            "dependencies": [
              1
            ],
            "details": "Implement an algorithm that weights recent performance more heavily than historical data. Allow for configurable weights (e.g., 70% recent 10 rounds, 30% season average) as specified in the requirements. Ensure the weighting system can be adjusted through the configuration options. Integrate this with the performance percentile calculation from subtask 1.\n<info added on 2025-07-01T00:19:52.726Z>\nImplemented a sophisticated time-weighted performance algorithm with three specialized weighting functions:\n\n1. Exponential decay function (applyExponentialDecay) that emphasizes recent performance with an 85/15 split\n2. Linear decay function (applyLinearDecay) with clamped recency weights for a more balanced approach\n3. Long-term weighting function (applyLongTermWeighting) that emphasizes season consistency with a 75/25 split\n\nAdded performance optimization through memoization caching (timeWeightedSGCache) with intelligent cache key generation that incorporates all relevant parameters. Enhanced the calculateTimeWeightedSG() function with intelligent time period handling and proper fallback logic when only one data source is available.\n\nImplemented clearTimeWeightedSGCache() function for testing and memory management purposes.\n\nThe system now successfully weights recent performance more heavily than historical data with configurable weights that can be adjusted through configuration options, fully integrated with the performance percentile calculation.\n</info added on 2025-07-01T00:19:52.726Z>",
            "status": "done",
            "testStrategy": "Test with different weighting configurations to verify that recent performance is appropriately emphasized. Compare results against manual calculations for a sample set of players."
          },
          {
            "id": 5,
            "title": "Implement Value Score Algorithm and UI Configuration",
            "description": "Complete the valueScore calculation algorithm and add UI configuration options",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Implement the core value score algorithm: valueScore = (performancePercentile - impliedProbabilityPercentile) * courseFitFactor. Integrate all components from previous subtasks. Add configuration UI options for time periods and weighting factors. Ensure the filter method correctly applies the threshold from config. Optimize the entire calculation process with memoization techniques.\n<info added on 2025-07-01T00:21:44.406Z>\nFinalized comprehensive value score algorithm with enhanced features and debugging capabilities. Enhanced core value score algorithm with sophisticated course fit adjustment. Implemented confidence calculation system (calculatePerformanceConfidence() and calculateOddsConfidence()). Added value quality metric that combines score with confidence rating. Enhanced sorting options to include 'value-quality' sort method. Implemented comprehensive debugging information including all calculation parameters. Added detailed summary statistics in meta response including averages and cache info. Created performance and odds confidence scoring based on data availability and quality. The complete SG Value filter now provides sophisticated value scoring with configurable course fit weighting, multi-format odds support with vig removal, time-weighted performance calculation with memoization, course DNA integration for fit analysis, comprehensive confidence metrics and debugging information, and detailed summary statistics for analysis.\n</info added on 2025-07-01T00:21:44.406Z>",
            "status": "done",
            "testStrategy": "Perform end-to-end testing with real player data to verify the complete value score calculation. Test UI configuration changes to ensure they properly affect the underlying calculations. Conduct performance testing to verify memoization improves calculation speed."
          }
        ]
      },
      {
        "id": 53,
        "title": "Enhance Balanced Filter Implementation",
        "description": "Upgrade the basic Balanced filter to calculate percentile ranks across all SG categories, implement threshold requirements, and create a comprehensive balance scoring algorithm.",
        "details": "1. Extend the existing Balanced filter class that implements FilterInterface\n2. Implement percentile rank calculations for all SG categories (OTT, APP, ARG, PUTT)\n3. Create a configurable threshold system with default minimum of 40th percentile\n4. Implement bonus scoring for excellence (e.g., +0.5 points for each category above 70th percentile)\n5. Add penalty scoring for weaknesses (e.g., -1.0 points for each category below 20th percentile)\n6. Develop a balance score formula: `balanceScore = (avg of all percentiles) + bonusPoints - penaltyPoints`\n7. Add UI configuration options for adjusting thresholds and weights\n8. Implement efficient caching of percentile calculations\n\nCode structure:\n```typescript\nexport class BalancedFilter implements FilterInterface {\n  private sgStatsService: SGStatsService;\n  \n  constructor(services: FilterServices) {\n    this.sgStatsService = services.sgStatsService;\n  }\n  \n  public filter(players: Player[], config: BalancedFilterConfig): Player[] {\n    // Implementation of enhanced algorithm\n    return players.filter(player => this.calculateBalanceScore(player, config) > config.threshold);\n  }\n  \n  private calculateBalanceScore(player: Player, config: BalancedFilterConfig): number {\n    const percentiles = this.calculateCategoryPercentiles(player, config.timeframe);\n    const avgPercentile = this.calculateAveragePercentile(percentiles);\n    const bonusPoints = this.calculateBonusPoints(percentiles, config.excellenceThreshold);\n    const penaltyPoints = this.calculatePenaltyPoints(percentiles, config.weaknessThreshold);\n    \n    return avgPercentile + bonusPoints - penaltyPoints;\n  }\n  \n  private calculateCategoryPercentiles(player: Player, timeframe: number): CategoryPercentiles {\n    // Calculate percentiles for each SG category\n  }\n}\n```",
        "testStrategy": "1. Unit test the balance score calculation with various player profiles\n2. Test threshold configurations to ensure proper filtering\n3. Verify percentile calculations against known statistical distributions\n4. Test edge cases: players with extreme variance across categories\n5. Benchmark performance with large datasets\n6. Integration test with the FilterPanel component\n7. Verify UI configuration options correctly affect the filtering results",
        "priority": "high",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Percentile Rank Calculations",
            "description": "Extend the BalancedFilter class to calculate percentile ranks across all SG categories (OTT, APP, ARG, PUTT).",
            "dependencies": [],
            "details": "Create a method to calculate percentile ranks for each SG category based on player performance data. Implement efficient data retrieval from sgStatsService. Add caching mechanism to avoid redundant calculations. Ensure the calculations work for different timeframes.",
            "status": "pending",
            "testStrategy": "Create unit tests with mock player data to verify percentile calculations match expected values. Test edge cases like players with missing data in certain categories."
          },
          {
            "id": 2,
            "title": "Develop Configurable Threshold System",
            "description": "Create a configurable threshold system with default minimum of 40th percentile and implement UI configuration options.",
            "dependencies": [
              1
            ],
            "details": "Extend BalancedFilterConfig interface to include threshold parameters. Implement default values (40th percentile minimum). Create UI components for adjusting thresholds. Ensure threshold values are properly validated and applied in the filter logic.",
            "status": "pending",
            "testStrategy": "Test that different threshold configurations correctly filter the player list. Verify UI components correctly update the configuration object."
          },
          {
            "id": 3,
            "title": "Implement Bonus and Penalty Scoring",
            "description": "Create methods to calculate bonus points for excellence (above 70th percentile) and penalty points for weaknesses (below 20th percentile).",
            "dependencies": [
              1
            ],
            "details": "Implement calculateBonusPoints method that adds +0.5 points for each category above the excellence threshold (default 70th percentile). Implement calculatePenaltyPoints method that subtracts -1.0 points for each category below the weakness threshold (default 20th percentile). Make thresholds and point values configurable.",
            "status": "pending",
            "testStrategy": "Test various player profiles to ensure bonus and penalty points are calculated correctly. Verify edge cases like players with all excellent or all weak categories."
          },
          {
            "id": 4,
            "title": "Develop Balance Score Formula",
            "description": "Implement the balance score calculation formula that combines average percentiles with bonus and penalty points.",
            "dependencies": [
              1,
              3
            ],
            "details": "Complete the calculateBalanceScore method to compute the final balance score using the formula: balanceScore = (avg of all percentiles) + bonusPoints - penaltyPoints. Ensure proper handling of edge cases and missing data. Optimize the calculation for performance.",
            "status": "pending",
            "testStrategy": "Create comprehensive tests with various player profiles to verify balance scores are calculated correctly. Test with different configurations to ensure the formula behaves as expected."
          },
          {
            "id": 5,
            "title": "Finalize Filter Implementation and UI Integration",
            "description": "Complete the filter method implementation and integrate all components with the UI configuration options.",
            "dependencies": [
              2,
              4
            ],
            "details": "Finalize the filter method to use the balance score for filtering players. Implement UI components for adjusting all configurable parameters (thresholds, weights, etc.). Add documentation for the enhanced filter functionality. Ensure efficient caching of calculations to optimize performance.",
            "status": "pending",
            "testStrategy": "Perform end-to-end testing with real player data to verify the filter correctly identifies balanced players. Test UI interactions to ensure configuration changes are properly reflected in the filter results."
          }
        ]
      },
      {
        "id": 54,
        "title": "Implement Player Archetype Filter",
        "description": "Create a new filter that leverages the existing player archetype classification system to filter players by playing styles such as bombers, scramblers, putters, and iron specialists.",
        "details": "1. Create a new PlayerArchetypeFilter class implementing FilterInterface\n2. Integrate with the existing player archetype service\n3. Define archetype categories based on the classification system (bombers, scramblers, putters, iron specialists)\n4. Implement multi-select functionality for archetype filtering\n5. Add weighting for archetype purity (how strongly a player fits an archetype)\n6. Create UI configuration options for archetype selection and threshold adjustment\n7. Register the filter in the initFilters.ts file\n\nCode structure:\n```typescript\nexport class PlayerArchetypeFilter implements FilterInterface {\n  private archetypeService: PlayerArchetypeService;\n  \n  constructor(services: FilterServices) {\n    this.archetypeService = services.archetypeService;\n  }\n  \n  public filter(players: Player[], config: PlayerArchetypeFilterConfig): Player[] {\n    const selectedArchetypes = config.selectedArchetypes;\n    const threshold = config.purityThreshold || 0.7; // Default 70% purity\n    \n    return players.filter(player => {\n      const playerArchetypes = this.archetypeService.getPlayerArchetypes(player.id);\n      return selectedArchetypes.some(archetype => \n        playerArchetypes[archetype] && playerArchetypes[archetype].purity >= threshold\n      );\n    });\n  }\n}\n\n// Register in initFilters.ts\nregisterCoreFilters({\n  // existing filters\n  playerArchetype: new PlayerArchetypeFilter(services)\n});\n```",
        "testStrategy": "1. Unit test the filter with mock archetype data\n2. Test multi-select functionality with various combinations\n3. Verify integration with the archetype service using mock responses\n4. Test threshold adjustments to ensure proper filtering\n5. Integration test with the FilterPanel component\n6. Verify UI configuration options correctly affect the filtering results\n7. Test with real player data to ensure meaningful differentiation",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create PlayerArchetypeFilter class",
            "description": "Implement the PlayerArchetypeFilter class that implements the FilterInterface with core filtering logic",
            "dependencies": [],
            "details": "Create a new file for PlayerArchetypeFilter class that implements FilterInterface. Implement the constructor to accept FilterServices and store the archetypeService. Implement the filter method that takes players array and config object, and returns filtered players based on archetype criteria.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify the filter correctly identifies players matching specific archetypes with various purity thresholds"
          },
          {
            "id": 2,
            "title": "Define archetype categories and configuration interface",
            "description": "Create type definitions for archetype categories and filter configuration options",
            "dependencies": [],
            "details": "Define an enum or string constants for archetype categories (bombers, scramblers, putters, iron specialists). Create a PlayerArchetypeFilterConfig interface that includes selectedArchetypes array and purityThreshold number properties. Document each archetype with its statistical characteristics.",
            "status": "pending",
            "testStrategy": "Ensure type definitions are correctly used throughout the implementation with TypeScript validation"
          },
          {
            "id": 3,
            "title": "Implement multi-select functionality",
            "description": "Add support for selecting multiple archetypes in the filter configuration",
            "dependencies": [
              1,
              2
            ],
            "details": "Enhance the filter method to handle multiple selected archetypes. Implement logic to return players that match any of the selected archetypes (OR logic) based on the purity threshold. Ensure the filter handles empty selections gracefully.",
            "status": "pending",
            "testStrategy": "Test with various combinations of selected archetypes to verify correct filtering behavior"
          },
          {
            "id": 4,
            "title": "Create UI configuration components",
            "description": "Develop UI components for archetype selection and threshold adjustment",
            "dependencies": [
              2
            ],
            "details": "Create a component for selecting archetypes with checkboxes or multi-select dropdown. Add a slider or input field for adjusting the purity threshold (0.0-1.0). Implement onChange handlers to update the filter configuration. Style components according to the application's design system.",
            "status": "pending",
            "testStrategy": "Test UI components with various user interactions to ensure they correctly update the filter configuration"
          },
          {
            "id": 5,
            "title": "Register and integrate the filter",
            "description": "Register the new filter in initFilters.ts and integrate with the existing filtering system",
            "dependencies": [
              1,
              3,
              4
            ],
            "details": "Add the PlayerArchetypeFilter to the registerCoreFilters function in initFilters.ts. Ensure the archetypeService is properly injected. Update any necessary filter management components to include the new filter option. Test the integration with the overall filtering system.",
            "status": "pending",
            "testStrategy": "Perform integration testing to verify the filter works correctly within the application's filtering framework"
          }
        ]
      },
      {
        "id": 55,
        "title": "Implement Momentum Filter",
        "description": "Create a new filter that tracks SG performance trends over configurable periods, implements recency weighting, and identifies positive/negative momentum patterns.",
        "details": "1. Create a new MomentumFilter class implementing FilterInterface\n2. Implement trend analysis for SG performance over configurable periods (4-8 rounds)\n3. Develop a recency-weighted algorithm that gives more importance to recent rounds\n4. Calculate momentum slopes using linear regression on recent performance data\n5. Implement strength of field adjustments based on tournament quality\n6. Create a momentum score formula: `momentumScore = slope * recencyWeight * fieldStrengthFactor`\n7. Add UI configuration options for time period and weighting factors\n8. Register the filter in the initFilters.ts file\n\nCode structure:\n```typescript\nexport class MomentumFilter implements FilterInterface {\n  private sgStatsService: SGStatsService;\n  private tournamentService: TournamentService;\n  \n  constructor(services: FilterServices) {\n    this.sgStatsService = services.sgStatsService;\n    this.tournamentService = services.tournamentService;\n  }\n  \n  public filter(players: Player[], config: MomentumFilterConfig): Player[] {\n    const periodRounds = config.periodRounds || 8; // Default to 8 rounds\n    const threshold = config.threshold || 0.5; // Default momentum threshold\n    \n    return players.filter(player => {\n      const momentumScore = this.calculateMomentumScore(player, periodRounds);\n      return momentumScore >= threshold;\n    });\n  }\n  \n  private calculateMomentumScore(player: Player, periodRounds: number): number {\n    const recentRounds = this.sgStatsService.getPlayerRounds(player.id, periodRounds);\n    const weightedPerformances = this.calculateWeightedPerformances(recentRounds);\n    const momentumSlope = this.calculateLinearRegressionSlope(weightedPerformances);\n    const fieldStrengthFactor = this.calculateFieldStrengthFactor(recentRounds);\n    \n    return momentumSlope * fieldStrengthFactor;\n  }\n  \n  private calculateLinearRegressionSlope(performances: WeightedPerformance[]): number {\n    // Implement linear regression to calculate slope\n  }\n}\n```",
        "testStrategy": "1. Unit test the momentum score calculation with various performance patterns\n2. Test the linear regression implementation with known datasets\n3. Verify recency weighting correctly prioritizes recent performances\n4. Test with different configuration settings to ensure proper filtering\n5. Benchmark performance with large datasets\n6. Integration test with the FilterPanel component\n7. Test edge cases: players with limited recent data, extreme performance swings",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement MomentumFilter Class Structure",
            "description": "Create the basic MomentumFilter class implementing FilterInterface with required services and method signatures.",
            "dependencies": [],
            "details": "Create MomentumFilter class with constructor accepting FilterServices, implement filter() method signature, and add private methods for momentum calculations. Register the filter in initFilters.ts file.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify class instantiation and proper implementation of FilterInterface."
          },
          {
            "id": 2,
            "title": "Develop Performance Trend Analysis",
            "description": "Implement the logic to analyze SG performance trends over configurable periods (4-8 rounds).",
            "dependencies": [
              1
            ],
            "details": "Create methods to retrieve player round data from sgStatsService, implement data structure for storing performance metrics, and develop functions to analyze trends over the specified period range.",
            "status": "pending",
            "testStrategy": "Test with mock player data having various performance patterns to verify trend identification."
          },
          {
            "id": 3,
            "title": "Implement Recency-Weighted Algorithm",
            "description": "Develop algorithm that gives more importance to recent rounds and calculate momentum slopes using linear regression.",
            "dependencies": [
              2
            ],
            "details": "Create calculateWeightedPerformances() method to apply recency weights to performance data. Implement calculateLinearRegressionSlope() method using standard linear regression formula to determine performance trajectory.",
            "status": "pending",
            "testStrategy": "Test with controlled datasets to verify recency weighting works correctly and slope calculations match expected values."
          },
          {
            "id": 4,
            "title": "Add Field Strength Adjustments",
            "description": "Implement strength of field adjustments based on tournament quality to factor into momentum calculations.",
            "dependencies": [
              2
            ],
            "details": "Create calculateFieldStrengthFactor() method that uses tournamentService to retrieve tournament quality data. Develop algorithm to adjust momentum scores based on the strength of competition faced.",
            "status": "pending",
            "testStrategy": "Test with tournaments of varying strengths to verify appropriate adjustments to momentum scores."
          },
          {
            "id": 5,
            "title": "Create UI Configuration Options",
            "description": "Add UI configuration options for time period and weighting factors and finalize momentum score formula.",
            "dependencies": [
              3,
              4
            ],
            "details": "Define MomentumFilterConfig interface with options for periodRounds, recencyWeight, and threshold. Implement the final momentumScore formula that combines slope, recency weight, and field strength factor. Create UI components for adjusting these parameters.",
            "status": "pending",
            "testStrategy": "Test UI components with different configurations to verify they correctly affect the filter results."
          }
        ]
      },
      {
        "id": 56,
        "title": "Implement Course Fit Filter",
        "description": "Create a new filter that integrates with the existing course DNA analysis system to match player strengths to course characteristics and calculate course fit scores.",
        "details": "1. Create a new CourseFitFilter class implementing FilterInterface\n2. Integrate with the existing course DNA analysis system\n3. Implement player-to-course matching algorithm based on key characteristics\n4. Analyze historical performance on similar course types\n5. Factor in current course conditions and setup\n6. Calculate a comprehensive fit score using multiple weighted factors\n7. Add UI configuration options for adjusting importance of different course factors\n8. Register the filter in the initFilters.ts file\n\nCode structure:\n```typescript\nexport class CourseFitFilter implements FilterInterface {\n  private courseDNAService: CourseDNAService;\n  private playerStatsService: PlayerStatsService;\n  \n  constructor(services: FilterServices) {\n    this.courseDNAService = services.courseDNAService;\n    this.playerStatsService = services.playerStatsService;\n  }\n  \n  public filter(players: Player[], config: CourseFitFilterConfig): Player[] {\n    const courseId = config.courseId;\n    const threshold = config.threshold || 0.6; // Default fit threshold\n    \n    if (!courseId) {\n      console.warn('Course Fit Filter: No course ID provided');\n      return players;\n    }\n    \n    const courseDNA = this.courseDNAService.getCourseDNA(courseId);\n    \n    return players.filter(player => {\n      const fitScore = this.calculateCourseFitScore(player, courseDNA, config);\n      return fitScore >= threshold;\n    });\n  }\n  \n  private calculateCourseFitScore(player: Player, courseDNA: CourseDNA, config: CourseFitFilterConfig): number {\n    const playerStrengths = this.playerStatsService.getPlayerStrengths(player.id);\n    const historicalPerformance = this.getHistoricalPerformanceOnSimilarCourses(player.id, courseDNA);\n    \n    // Calculate weighted fit score based on multiple factors\n    const strengthMatchScore = this.calculateStrengthMatch(playerStrengths, courseDNA);\n    const historicalScore = this.calculateHistoricalScore(historicalPerformance);\n    \n    return (strengthMatchScore * config.strengthWeight) + \n           (historicalScore * config.historicalWeight);\n  }\n}\n```",
        "testStrategy": "1. Unit test the course fit score calculation with various player profiles and course types\n2. Test with different course DNA profiles to ensure proper matching\n3. Verify historical performance analysis with mock data\n4. Test with different configuration weights to ensure proper prioritization\n5. Integration test with the FilterPanel component\n6. Verify UI configuration options correctly affect the filtering results\n7. Test with real course and player data to ensure meaningful differentiation",
        "priority": "medium",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Create CourseFitFilter class structure",
            "description": "Implement the basic structure of the CourseFitFilter class that implements FilterInterface with required services and method signatures.",
            "dependencies": [],
            "details": "Create the CourseFitFilter class with constructor that accepts FilterServices, implement the filter method signature, and define private methods for score calculation. Ensure proper typing for all parameters and return values.",
            "status": "pending",
            "testStrategy": "Write unit tests to verify the class instantiates correctly and implements all required interface methods."
          },
          {
            "id": 2,
            "title": "Implement player-to-course matching algorithm",
            "description": "Develop the core algorithm that matches player strengths to course characteristics to determine compatibility.",
            "dependencies": [
              1
            ],
            "details": "Implement the calculateStrengthMatch method that compares player strengths from PlayerStatsService with course DNA attributes. Consider factors like driving accuracy, putting, approach play, and how they align with course features.",
            "status": "pending",
            "testStrategy": "Test with mock player and course data to ensure the strength matching algorithm produces expected scores for known player-course combinations."
          },
          {
            "id": 3,
            "title": "Add historical performance analysis",
            "description": "Implement functionality to analyze a player's historical performance on similar course types.",
            "dependencies": [
              1
            ],
            "details": "Create methods to retrieve and analyze a player's past performance on courses with similar DNA profiles. Implement the calculateHistoricalScore method to weight recent performances more heavily than older ones.",
            "status": "pending",
            "testStrategy": "Create test cases with mock historical data to verify the historical performance analysis correctly identifies and weights performance patterns."
          },
          {
            "id": 4,
            "title": "Implement comprehensive fit score calculation",
            "description": "Develop the weighted scoring system that combines multiple factors into a single course fit score.",
            "dependencies": [
              2,
              3
            ],
            "details": "Complete the calculateCourseFitScore method to combine strength matching, historical performance, and current course conditions with configurable weights. Ensure the final score is normalized between 0 and 1.",
            "status": "pending",
            "testStrategy": "Test with various weight configurations to ensure the scoring system behaves as expected and properly balances different factors."
          },
          {
            "id": 5,
            "title": "Register and integrate the filter",
            "description": "Register the new filter in the application and add UI configuration options for adjusting factor weights.",
            "dependencies": [
              4
            ],
            "details": "Add the filter to initFilters.ts, create UI components for configuring the filter weights and threshold, and ensure the filter integrates properly with the existing filtering system. Include documentation on how to use the new filter.",
            "status": "pending",
            "testStrategy": "Perform integration tests to verify the filter works correctly within the application and UI controls properly adjust the filter behavior."
          }
        ]
      },
      {
        "id": 57,
        "title": "Implement Form/Consistency Filter",
        "description": "Create a new filter that analyzes recent tournament results and performance patterns to calculate consistency metrics and provide form-based player rankings.",
        "details": "1. Create a new FormConsistencyFilter class implementing FilterInterface\n2. Implement statistical analysis for consistency measurement (standard deviation, variance)\n3. Develop trend analysis over configurable periods (recent tournaments)\n4. Create weighting system based on field strength and course similarity\n5. Calculate a form score combining recent results and consistency metrics\n6. Add UI configuration options for time period and consistency thresholds\n7. Register the filter in the initFilters.ts file\n\nCode structure:\n```typescript\nexport class FormConsistencyFilter implements FilterInterface {\n  private tournamentService: TournamentService;\n  private playerStatsService: PlayerStatsService;\n  \n  constructor(services: FilterServices) {\n    this.tournamentService = services.tournamentService;\n    this.playerStatsService = services.playerStatsService;\n  }\n  \n  public filter(players: Player[], config: FormConsistencyFilterConfig): Player[] {\n    const periodTournaments = config.periodTournaments || 10; // Default to 10 tournaments\n    const consistencyThreshold = config.consistencyThreshold || 0.7; // Default consistency threshold\n    const formThreshold = config.formThreshold || 0.6; // Default form threshold\n    \n    return players.filter(player => {\n      const formScore = this.calculateFormScore(player, periodTournaments);\n      const consistencyScore = this.calculateConsistencyScore(player, periodTournaments);\n      \n      return formScore >= formThreshold && consistencyScore >= consistencyThreshold;\n    });\n  }\n  \n  private calculateFormScore(player: Player, periodTournaments: number): number {\n    const recentResults = this.tournamentService.getPlayerResults(player.id, periodTournaments);\n    const weightedResults = this.calculateWeightedResults(recentResults);\n    \n    // Calculate form score based on weighted recent results\n    return this.calculateWeightedAverage(weightedResults);\n  }\n  \n  private calculateConsistencyScore(player: Player, periodTournaments: number): number {\n    const recentResults = this.tournamentService.getPlayerResults(player.id, periodTournaments);\n    const standardDeviation = this.calculateStandardDeviation(recentResults);\n    \n    // Convert standard deviation to a consistency score (lower deviation = higher consistency)\n    return 1 - (standardDeviation / 10); // Normalize to 0-1 scale\n  }\n}\n```",
        "testStrategy": "1. Unit test the form and consistency score calculations with various performance patterns\n2. Test the standard deviation and variance calculations with known datasets\n3. Verify weighting by field strength correctly adjusts scores\n4. Test with different configuration settings to ensure proper filtering\n5. Benchmark performance with large datasets\n6. Integration test with the FilterPanel component\n7. Test edge cases: players with limited tournament history, extreme performance variance",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement FormConsistencyFilter class structure",
            "description": "Create the FormConsistencyFilter class implementing FilterInterface with necessary service dependencies and basic filter method structure.",
            "dependencies": [],
            "details": "Create the class with constructor that accepts FilterServices, implement the filter method with proper parameter typing, and set up the basic structure for the two calculation methods. Ensure the class properly implements all required interface methods.",
            "status": "pending",
            "testStrategy": "Create unit tests to verify the class instantiates correctly and implements the FilterInterface properly."
          },
          {
            "id": 2,
            "title": "Implement consistency calculation logic",
            "description": "Develop the statistical analysis methods for measuring player consistency using standard deviation and variance calculations.",
            "dependencies": [
              1
            ],
            "details": "Complete the calculateConsistencyScore method to properly analyze tournament results, calculate standard deviation of performance, and normalize the results to a 0-1 scale. Include handling for edge cases like insufficient data.",
            "status": "pending",
            "testStrategy": "Test with mock player data having various consistency patterns to verify the calculations produce expected consistency scores."
          },
          {
            "id": 3,
            "title": "Implement form calculation logic",
            "description": "Develop the trend analysis and weighted scoring system for recent tournament performance.",
            "dependencies": [
              1
            ],
            "details": "Complete the calculateFormScore and calculateWeightedResults methods to analyze recent tournament results, apply appropriate weighting based on field strength and course similarity, and calculate a normalized form score.",
            "status": "pending",
            "testStrategy": "Test with mock tournament data to verify the weighting system and form calculations produce expected results for players with different recent performance patterns."
          },
          {
            "id": 4,
            "title": "Add UI configuration options",
            "description": "Create the UI components for configuring time period and consistency/form thresholds.",
            "dependencies": [
              1,
              2,
              3
            ],
            "details": "Develop UI controls for adjusting periodTournaments, consistencyThreshold, and formThreshold parameters. Ensure proper validation and default values are applied. Update the FilterConfig interface to include the new configuration options.",
            "status": "pending",
            "testStrategy": "Test UI components to ensure they correctly update filter configuration and apply changes to the filter results."
          },
          {
            "id": 5,
            "title": "Register and integrate the filter",
            "description": "Register the new filter in the initFilters.ts file and ensure proper integration with the existing filtering system.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Add the FormConsistencyFilter to the initFilters.ts file, ensuring it's properly instantiated with required services. Test the complete filter integration to verify it works correctly with the existing filter system and UI.",
            "status": "pending",
            "testStrategy": "Create integration tests to verify the filter works correctly when combined with other filters and produces expected results in the full application context."
          }
        ]
      },
      {
        "id": 58,
        "title": "Implement Weather Filter",
        "description": "Create a new filter that analyzes historical performance under various weather conditions, factors in forecasted weather, and adjusts SG statistics for weather impacts.",
        "details": "1. Create a new WeatherFilter class implementing FilterInterface\n2. Integrate with weather data sources for current and forecasted conditions\n3. Analyze historical player performance under similar weather conditions\n4. Implement weather impact adjustments for SG statistics\n5. Calculate weather-adjusted performance scores\n6. Add UI configuration options for weather condition selection\n7. Register the filter in the initFilters.ts file\n\nCode structure:\n```typescript\nexport class WeatherFilter implements FilterInterface {\n  private weatherService: WeatherService;\n  private playerStatsService: PlayerStatsService;\n  private tournamentService: TournamentService;\n  \n  constructor(services: FilterServices) {\n    this.weatherService = services.weatherService;\n    this.playerStatsService = services.playerStatsService;\n    this.tournamentService = services.tournamentService;\n  }\n  \n  public filter(players: Player[], config: WeatherFilterConfig): Player[] {\n    const tournamentId = config.tournamentId;\n    const threshold = config.threshold || 0.6; // Default weather performance threshold\n    \n    if (!tournamentId) {\n      console.warn('Weather Filter: No tournament ID provided');\n      return players;\n    }\n    \n    const forecastedConditions = this.weatherService.getForecastedConditions(tournamentId);\n    \n    return players.filter(player => {\n      const weatherScore = this.calculateWeatherPerformanceScore(player, forecastedConditions);\n      return weatherScore >= threshold;\n    });\n  }\n  \n  private calculateWeatherPerformanceScore(player: Player, forecastedConditions: WeatherConditions): number {\n    // Get historical performance under similar conditions\n    const historicalPerformance = this.getHistoricalPerformanceInWeather(\n      player.id, \n      forecastedConditions\n    );\n    \n    // Calculate weather-adjusted SG stats\n    const adjustedStats = this.calculateWeatherAdjustedStats(\n      player.id, \n      forecastedConditions\n    );\n    \n    // Combine historical performance and adjusted stats\n    return (historicalPerformance * 0.7) + (adjustedStats * 0.3);\n  }\n  \n  private getHistoricalPerformanceInWeather(playerId: string, conditions: WeatherConditions): number {\n    // Implementation to find and score historical performance in similar weather\n  }\n  \n  private calculateWeatherAdjustedStats(playerId: string, conditions: WeatherConditions): number {\n    // Implementation to adjust SG stats based on weather impact factors\n  }\n}\n```",
        "testStrategy": "1. Unit test the weather performance score calculation with various weather conditions\n2. Test with mock weather forecast data to ensure proper integration\n3. Verify historical weather performance analysis with mock data\n4. Test the weather adjustment factors for SG statistics\n5. Integration test with the FilterPanel component\n6. Verify UI configuration options correctly affect the filtering results\n7. Test with real weather and player data to ensure meaningful differentiation",
        "priority": "low",
        "dependencies": [],
        "status": "pending",
        "subtasks": [
          {
            "id": 1,
            "title": "Implement Weather Data Integration",
            "description": "Create methods to fetch and process current and forecasted weather conditions from the WeatherService.",
            "dependencies": [],
            "details": "Implement the integration with WeatherService to retrieve forecasted conditions for a tournament. Create helper methods to parse and standardize weather data formats. Handle potential API failures gracefully with appropriate error handling and fallback mechanisms.",
            "status": "pending",
            "testStrategy": "Write unit tests that mock WeatherService responses for various weather conditions and verify correct data processing."
          },
          {
            "id": 2,
            "title": "Develop Historical Weather Performance Analysis",
            "description": "Implement the getHistoricalPerformanceInWeather method to analyze player performance under similar weather conditions.",
            "dependencies": [
              1
            ],
            "details": "Query the PlayerStatsService to retrieve historical tournament data where weather conditions were similar to the forecasted conditions. Calculate performance metrics based on past tournaments with similar weather. Consider factors like wind speed, precipitation, temperature, and humidity in the analysis.",
            "status": "pending",
            "testStrategy": "Test with mock historical data representing various weather scenarios to verify correct performance scoring."
          },
          {
            "id": 3,
            "title": "Create Weather-Adjusted SG Statistics",
            "description": "Implement the calculateWeatherAdjustedStats method to adjust Strokes Gained statistics based on weather impact factors.",
            "dependencies": [
              1
            ],
            "details": "Develop algorithms to adjust SG statistics based on weather conditions. Consider how different weather elements affect different aspects of the game (driving, approach, putting). Create adjustment factors for each SG category based on weather severity and player characteristics.",
            "status": "pending",
            "testStrategy": "Test with various weather scenarios and player profiles to ensure adjustments are reasonable and consistent."
          },
          {
            "id": 4,
            "title": "Complete Filter Implementation",
            "description": "Finalize the filter method to combine historical performance and adjusted stats into a comprehensive weather performance score.",
            "dependencies": [
              2,
              3
            ],
            "details": "Implement the main filter logic that combines historical performance (70% weight) and adjusted stats (30% weight). Add configuration options for threshold values and weighting factors. Ensure the filter correctly returns players who meet the threshold criteria.",
            "status": "pending",
            "testStrategy": "Create integration tests with mock player data to verify the filter correctly identifies players who perform well in the forecasted conditions."
          },
          {
            "id": 5,
            "title": "Add UI Configuration and Register Filter",
            "description": "Create UI configuration options for weather condition selection and register the filter in initFilters.ts.",
            "dependencies": [
              4
            ],
            "details": "Design and implement UI components for weather filter configuration, including options to select specific weather conditions to filter by. Add the filter to the initFilters.ts file to make it available in the application. Document the new filter's capabilities and configuration options for users.",
            "status": "pending",
            "testStrategy": "Perform end-to-end testing to verify the filter appears correctly in the UI and functions as expected when configured through the interface."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-20T10:28:54.452Z",
      "updated": "2025-07-01T00:21:48.739Z",
      "description": "Tasks for master context"
    }
  }
}